{
  "id": "dora.dev_1750320049044_ZG9yYS5k",
  "source": "dora.dev",
  "url": "https://dora.dev/capabilities/trunk-based-development/",
  "title": "DORA | Capabilities: Trunk-based Development",
  "content": "There are two main patterns for developer teams to work together using version control. One is to use feature branches, where either a developer or a group of developers create a branch usually from trunk (also known as main or mainline) and then work in isolation on that branch until the feature they are building is complete. When the team considers the feature ready to go, they merge the feature branch back to trunk. The second pattern is known as trunk-based development, where each developer divides their own work into small batches and merges that work into trunk at least once (and potentially several times) a day. The key difference between these approaches is scope. Feature branches typically involve multiple developers and take days or even weeks of work. In contrast, branches in trunk-based development typically last no more than a few hours, with many developers merging their individual changes into trunk frequently. The following diagram shows a typical trunk-based development timeline: In trunk-based development, developers push code directly into trunk. Changes made in the release branches—snapshots of the code when it’s ready to be released—are usually merged back to trunk (depicted by the downward arrows) as soon as possible. In this approach, there are cases where bug fixes must be cherry picked and merged into releases (depicted by the upward arrow), but these cases are not as frequent as the development of new features in trunk. In cases where releases happen multiple times a day, release branches are not required at all, because changes can be pushed directly into trunk and deployed from there. One key benefit of the trunk-based approach is that it reduces the complexity of merging events and keeps code current by having fewer development lines and by doing small and frequent merges. In contrast, the following diagram shows a typical non-trunk-based development style: In this approach, developers make changes to long-lived branches. These changes require bigger and more complex merge events when compared to trunk-based development. This approach also requires additional stabilizing efforts and “code lock” or “code freeze” periods to make sure the software stays in a working state, because large merges frequently introduce bugs or regressions. As a result, you must test the post-merge code thoroughly and often have to make bug fixes. How to implement trunk-based developmentlink click to copy link Trunk-based development is a required practice for continuous integration. Continuous integration (CI) is the combination of practicing trunk-based development and maintaining a suite of fast automated tests that run after each commit to trunk to make sure the system is always working. The point of using continuous integration is to eliminate long integration and stabilization phases by integrating small batches of code frequently. In this way, developers ensure they are communicating what they are doing, and the integration gets rid of big merges that can create substantial work for other developers and for testers. In the CI paradigm, developers are responsible for keeping the build process green—that is, up and running. This means that if the CI process fails, developers must stop what they’re doing either to fix the problem immediately or to revert the change if it can’t be fixed in a few minutes. Practicing trunk-based development requires in turn that developers understand how to break their work up into small batches. This is a significant change for developers who aren’t used to working in this way. Analysis of DORA data from 2016 (PDF) and 2017 (PDF) shows that teams achieve higher levels of software delivery and operational performance (delivery speed, stability, and availability) if they follow these practices: Have three or fewer active branches in the application’s code repository. Merge branches to trunk at least once a day. Don’t have code freezes and don’t have integration phases. Common pitfallslink click to copy link Some common obstacles to full adoption of trunk-based development include the following: An overly heavy code-review process. Many organizations have a heavyweight code review process that requires multiple approvals before changes can be merged into trunk. When code review is laborious and takes hours or days, developers avoid working in small batches and instead batch up many changes. This in turn leads to a downward spiral where reviewers procrastinate with large code reviews due to their complexity. Consequently, merge requests often languish because developers avoid them. Because it is hard to reason about the impact of large changes on a system through inspection, defects are likely to escape the attention of reviewers, and the benefits of trunk-based development are diminished. Performing code reviews asynchronously. If your team practices pair programming, then the code has already been reviewed by a second person. If further reviews are required, they should be performed synchronously: when the developer is ready to commit the code, they should ask somebody else on the team to review the code right then. They should not ask for asynchronous review—for example, by submitting a request into a tool and then starting on a new task while waiting for the review. The longer a merge is delayed, the more likely it is to create merge conflicts and associated issues. Implementing synchronous reviews requires the agreement of the team to prioritize reviewing each others’ code over other work. Not running automated tests before committing code. In order to ensure trunk is kept in a working state, it’s essential that tests are run against code changes before commit. This can be done on developer workstations, and many tools also provide a facility to run tests remotely against local changes and then commit automatically when they pass. When developers know that they can get their code into trunk without a great deal of ceremony, the result is small code changes that are easy to understand, review, test, and which can be moved into production faster. Ways to improve trunk-based developmentlink click to copy link Based on the discussion earlier, here are some practices you can implement to improve trunk-based development: Develop in small batches. One of the most important enablers of trunk-based development is teams learning how to develop in small batches. This requires training and organizational support for the development team. Perform synchronous code review. As discussed previously, moving to synchronous code review, or at least ensuring that developers prioritize code review, helps to ensure that changes don’t have to wait hours, or even days, to get merged into trunk. Implement comprehensive automated testing. Make sure that you have a comprehensive and meaningful suite of automated unit tests. and that these are run before every commit. For example, if you’re using GitHub, you can protect branches to only allow pull request merges when all tests have passed. The Running builds with GitHub Checks tutorial shows how to integrate GitHub Checks with Cloud Build. Have a fast build. The build and test process should execute in a few minutes. If this seems hard to achieve, it probably indicates opportunities for improvement in the architecture of the system. Create a core group of advocates and mentors. Trunk-based development is a substantial change for many developers, and you should expect some resistance. Many developers simply can’t imagine working in this way. A good practice is to find developers who have worked in this way, and have them coach other developers. It’s also important to shift some teams over to work in a trunk-based style. One way to do this is to get a critical mass of developers who are experienced with trunk-based development together so that at least one team is following trunk-based development practices. You can then shift other teams over to this style when you feel confident that the team following this practice is performing as expected. Ways to measure trunk-based developmentlink click to copy link You can measure the effectiveness of trunk-based development by doing the following. Factor to test What to measure Goal Active branches on the application's code repository. Measure how many active branches you have on your application repositories' version control systems and make this number visible to all teams. Then track the incremental progress towards the goal state. Three or fewer active branches. Code freeze periods. Measure how many code freezes your team has and how long they last. These measurements can also categorize how much time is spent on merging conflicts, on code freezes, on stabilization, and so on. No code freezes when no one can submit code. Frequency of merging branches and forks to trunk. Measure either a binary (yes/no) value for each branch that's merged, or measure a percentage of branches and forks that are merged every day. Merging at least once per day. Check time taken to approve code changes. If you perform code review asynchronously, measure the average time it takes to approve change requests, and pay particular attention to requests that take substantially longer than the average. Find ways to make code review a synchronous activity that's performed as part of development. What’s nextlink click to copy link For links to other articles and resources, see the Google Cloud DevOps page. See Running builds with GitHub Checks for learning how to connect Google Cloud to GitHub using Cloud Build. See an article by Martin Fowler on feature branching. See Jez Humble’s post on DVCS and feature branches. See Paul Hammant’s portal devoted to trunk-based development. Explore our DevOps research program. Take the DORA quick check to understand where you stand in comparison with the rest of the industry.",
  "timestamp": "2025-06-19T08:00:49.044Z",
  "metadata": {
    "domain": "dora.dev",
    "contentType": "public",
    "authMethod": "none",
    "wordCount": 1570,
    "links": [
      "https://dora.dev/",
      "https://dora.dev/publications/",
      "https://dora.dev/research/",
      "https://dora.dev/capabilities/",
      "https://dora.dev/guides/",
      "https://dora.dev/quickcheck/",
      "https://dora.community/",
      "https://dora.dev/search/",
      "https://google.qualtrics.com/jfe/form/SV_40i28bp9qIMfNjw?source=doradotdev-survey",
      "https://dora.dev/capabilities",
      "https://dora.dev/capabilities/working-in-small-batches",
      "https://dora.dev/capabilities/continuous-integration",
      "https://dora.dev/research/2016/2016-state-of-devops-report.pdf#page=31",
      "https://dora.dev/research/2017-and-earlier/2017-state-of-devops-report.pdf#page=40",
      "https://dora.dev/capabilities/test-automation",
      "https://help.github.com/en/articles/about-protected-branches",
      "https://cloud.google.com/build/docs/run-builds-with-github-checks",
      "https://developer.github.com/v3/checks/",
      "https://cloud.google.com/build/",
      "https://www.infoq.com/presentations/Crazy-Fast-Build-Times-or-When-10-Seconds-Starts-to-Make-You-Nervous/",
      "https://dora.dev/capabilities/loosely-coupled-teams",
      "https://cloud.google.com/devops",
      "https://github.com/marketplace/google-cloud-build",
      "https://martinfowler.com/bliki/FeatureBranch.html",
      "https://continuousdelivery.com/2011/07/on-dvcs-continuous-integration-and-feature-branches/",
      "https://trunkbaseddevelopment.com/",
      "https://dora.dev/capabilities/code-maintainability/",
      "https://dora.dev/capabilities/documentation-quality/",
      "https://dora.dev/capabilities/teams-empowered-to-choose-tools/",
      "https://dora.dev/capabilities/generative-organizational-culture/",
      "https://dora.dev/capabilities/job-satisfaction/",
      "https://dora.dev/capabilities/learning-culture/",
      "https://dora.dev/capabilities/team-experimentation/",
      "https://dora.dev/capabilities/transformational-leadership/",
      "https://dora.dev/capabilities/well-being/",
      "https://dora.dev/capabilities/continuous-delivery/",
      "https://dora.dev/capabilities/database-change-management/",
      "https://dora.dev/capabilities/deployment-automation/",
      "https://dora.dev/capabilities/flexible-infrastructure/",
      "https://dora.dev/capabilities/loosely-coupled-teams/",
      "https://dora.dev/capabilities/streamlining-change-approval/",
      "https://dora.dev/capabilities/trunk-based-development/",
      "https://dora.dev/capabilities/version-control/",
      "https://dora.dev/capabilities/visual-management/",
      "https://dora.dev/capabilities/wip-limits/",
      "https://dora.dev/capabilities/working-in-small-batches/",
      "https://dora.dev/capabilities/continuous-integration/",
      "https://dora.dev/capabilities/customer-feedback/",
      "https://dora.dev/capabilities/monitoring-and-observability/",
      "https://dora.dev/capabilities/monitoring-systems/",
      "https://dora.dev/capabilities/pervasive-security/",
      "https://dora.dev/capabilities/proactive-failure-notification/",
      "https://dora.dev/capabilities/test-automation/",
      "https://dora.dev/capabilities/test-data-management/",
      "https://dora.dev/capabilities/work-visibility-in-value-stream/",
      "https://cloud.google.com/",
      "https://dora.dev/resources/",
      "https://dora.dev/faq/",
      "https://dora.dev/contact/",
      "https://creativecommons.org/licenses/by-nc-sa/4.0/",
      "https://www.linkedin.com/company/doradotdev/",
      "https://www.youtube.com/@dora-dev",
      "https://github.com/dora-team/dora.dev"
    ],
    "images": [
      "https://dora.dev/img/dora-logo.svg",
      "https://dora.dev/capabilities/trunk-based-development/trunk-based-development-typical-trunk-timeline.svg",
      "https://dora.dev/capabilities/trunk-based-development/trunk-based-development-typical-non-trunk-timeline.svg",
      "https://dora.dev/img/cloud-logo-dark.svg"
    ],
    "headings": [
      "H4: Capabilities: fast flow",
      "H1: Trunk-based development",
      "H2: How to implement trunk-based developmentlink click to copy link",
      "H2: Common pitfallslink click to copy link",
      "H2: Ways to improve trunk-based developmentlink click to copy link",
      "H2: Ways to measure trunk-based developmentlink click to copy link",
      "H2: What’s nextlink click to copy link",
      "H4: Capabilities",
      "H5: Climate for Learning",
      "H5: Fast Flow",
      "H5: Fast Feedback"
    ],
    "description": "DORA is a long running research program that seeks to understand the capabilities that drive software delivery and operations performance. DORA helps teams apply those capabilities, leading to better organizational performance.",
    "keywords": "DevOps, Lead time, Deploy frequency, Change fail rate, MTTR, Time to restore, metrics, DORA",
    "author": "",
    "language": "en"
  },
  "filePath": "C:\\agents\\kb-agent\\scraped\\dora.dev\\2025\\06\\1750320049044_DORA_Capabilities_Trunk-based_Development.json"
}